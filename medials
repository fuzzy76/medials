#!/usr/bin/php
<?php

// ffprobe -v quiet -print_format json -show_format -show_streams -select_streams u Broken\ City.mkv

if ($handle = opendir('.')) {
  while (false !== ($entry = readdir($handle))) {
    if (substr($entry,0,1) != '.' && (is_file($entry))) {
      $file = new MediaFile($entry);
      echo $file->singleLine();
      echo "\n";
    }
  }
  closedir($handle);
}

class MediaFile {
  public $fileinfo = '';
  public $filename;
  public $streams = array();
  function __construct($filename) {
    $run = "ffprobe -v quiet -print_format json -show_format -show_streams -show_error -select_streams u '$filename'";
    $fileinfo = shell_exec($run);
    $fileinfo = json_decode($fileinfo);
    $this->filename = $filename;
    $this->fileinfo = $fileinfo;
    if (count($fileinfo->streams)) {
      foreach($fileinfo->streams as $stream) {
        $newstream = new MediaStream($stream);
        $this->streams[] = $newstream;

      }
    }
  }

  function singleLine() {
    $vstreams = MediaFile::formatStreams($this->getStreams('video'));
    $astreams = MediaFile::formatStreams($this->getStreams('audio'));
    return sprintf("%-60.60s %10s %20.20s %20.20s %20.20s",$this->filename, $this->guessType(), $this->getContainer(), $vstreams, $astreams);
  }

  function getContainer() {
    return $this->fileinfo->format->format_name;
  }

  function getStreams($filter) {
    if (!count($this->streams)) {
      return array();
    }
    $out = array();
    foreach($this->streams as $stream) {
      if ($stream->getType() == $filter) {
        $out[] = $stream;
      }
    }
    return $out;
  }

  function countStreams($filter) {
    if (!count($this->streams)) {
      return 0;
    }
    $out = 0;
    foreach($this->streams as $stream) {
      if ($stream->getType() == $filter) {
        $out++;
      }
    }
    return $out;
  }

  function guessType() {
    if ($this->countStreams('video'))
      return 'video';

    if ($this->countStreams('audio'))
      return 'audio';

    return 'other';

  }

  static function formatStreams($streams) {
    $out = array();
    if (count($streams)) {
      foreach ($streams as $stream) {
        $bitrate = $stream->getBitrateFormatted();
        $out[] = $stream->getCodec() . ($bitrate ? "($bitrate)" : '');
      }
    }
    $out = implode(',', $out);
    return $out;
  }

  function __toString() {
    return print_r($this, TRUE);
  }

}

class MediaStream {
  public $streamdata = NULL;
  function __construct($stream) {
    $this->streamdata = $stream;
  }

  function getType() {
    // @todo We probably want to override the type here for some imageformats
    return $this->streamdata->codec_type;
  }

  function getBitrateFormatted() {
    $number = $this->getBitrate();
    if (!$number)
      return NULL;
    $sz = 'BKMGTP';
    $factor = floor((strlen($number) - 1) / 3);
    $out = round($number / pow(1024, $factor), 1);
    $letter = ($factor ? @$sz[$factor] : ''); // Skip first letter
    if ($out == 0)
      echo $this;
    return "{$out} {$letter}b";
  }

  function getBitrate() {
    if (isset($this->streamdata->bit_rate))
      return $this->streamdata->bit_rate;
    if (isset($this->streamdata->max_bit_rate))
      return $this->streamdata->max_bit_rate;
    return NULL;
  }

  function getCodec() {
    return $this->streamdata->codec_name;
  }

  function __toString() {
    return print_r($this, TRUE);
  }
}

function errorout($text, $data = '') {
  echo "$text : $data\n";
}

/*
TODO
- More intelligent rate calculation (also handle vbr)
- Filetype filtering (skip unknown files?)
- Filesize reporting
- Sort files (for now, pipe into sort)
- Intelligent tabulation
- Skip hidden files
- Subtitle languages(?)
- Do not regard png as video
- Ignore folders
*/
